<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python的SQL性能测试]]></title>
    <url>%2FPython%2FPython%E7%9A%84SQL%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html</url>
    <content type="text"><![CDATA[“实践是检验真理的唯一标准”前言测试异步与同步下Python对于PostgreSQL数据库操作的性能通过测试同步以及异步下对于数据库的增加和查找操作，以进行性能评估。更直观的以及量化地感受同步以及异步下的性能差距。环境初始化代码地址需要安装pipenv，详细内容可参考12345pip3.6 install pipenvgit clone https://github.com/GuangTianLi/python-sql-performance.gitcd python-sql-performancepipenv syncpipenv shellSQL操作性能评估1234567891011python postgresql_speed_test.py DBAPI: psycopg2 11004 function calls in 2.235 seconds DBAPI: asyncpg 471973 function calls in 2.436 seconds DBAPI: uvloop 206945 function calls in 0.794 seconds DBAPI: psycopg2, total seconds 2.558364 DBAPI: asyncpg, total seconds 2.309759 DBAPI: uvloop, total seconds 2.032303结论从结果上看，对于数据库操作本身，异步对于其性能本身只能算是锦上添花。而异步操作本身则也需要添加对事件循环的处理，等于是变相的增加了运行时间，而如果每个数据库操作本身所需要的时间小于事件循环处理的时间，则其总时间就是增加的。所以异步架构在用于单纯的数据库操作时，并不能取得非常良好的性能优化，数据库操作本身的优化还是依赖于操作本身以及数据库结构的优化。WebServer性能评估flask1python flask_server_speed_test.py123456789wrk -d 60 -c 100 -t 12 --timeout 8 http://127.0.0.1:8080/dbRunning 1m test @ http://127.0.0.1:8080/db 12 threads and 100 connections Thread Stats Avg Stdev Max +/- Stdev Latency 331.47ms 221.85ms 2.01s 89.71% Req/Sec 30.95 17.90 80.00 63.85% 18597 requests in 1.00m, 3.10MB readRequests/sec: 309.41Transfer/sec: 52.88KBsanic1python sanic_server_speed_test.py123456789wrk -d 60 -c 100 -t 12 --timeout 8 http://127.0.0.1:8080/dbRunning 1m test @ http://127.0.0.1:8080/db 12 threads and 100 connections Thread Stats Avg Stdev Max +/- Stdev Latency 162.95ms 99.56ms 1.89s 87.88% Req/Sec 52.26 23.73 148.00 61.57% 36702 requests in 1.00m, 4.83MB readRequests/sec: 610.64Transfer/sec: 82.29KB结论从中等量级的压测的结果上看，对于异步架构的网络服务器，在性能上有了很大的提升。]]></content>
      <categories>
        <category>Python</category>
        <category>Performance</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Performance</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[效率]]></title>
    <url>%2F%E6%95%88%E7%8E%87.html</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器前言该博文用于记录一些非常实用插件以及工具，以及一些程序或者配置文件的示范样例。theFucktheFuck是一款用于纠正前一个命令行命令。123456➜ ~ mkdir no-exist/no-existmkdir: no-exist: No such file or directory➜ ~ fuckmkdir -p no-exist/no-exist [enter/↑/↓/ctrl+c]➜ ~ cd no-exist/no-exist➜ no-exist安装OS X1brew install thefuckUbuntutheFuck需要安装Python3.4+作为前置依赖，[参见]1sudo pip3.6 install thefuck使用安装好之后务必将下面的命令添加至.zshrc文件123eval $(thefuck --alias)# 或者设置其他别名eval $(thefuck --alias FUCK)新打开一个终端会话fuckoh-my-zsh插件zsh-autosuggestionszsh-autosuggestions是一款根据历史记录里的命令自动补全建议克隆该项目到oh-my-zsh的plugins文件夹1git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions将该插件写入.zshrc文件：plugins=(zsh-autosuggestions)新打开一个终端会话gitgit插件设置了一些常用git命令的缩写，以及常用git相关函数，详细参见wikigit bisect命令帮助快速定位BUG所在改动，详细用法12345678910111213141516171819202122232425262728293031323334353637383940alias g='git'alias ga='git add' # 添加文件到暂存区alias gaa='git add --all' # 添加所有文件到暂存区alias gb='git branch' # 列出所有本地分支alias gba='git branch -a' # 列出所有本地以及远程分支alias gbd='git branch -d' # 删除分支alias gbl='git blame -b -w' # 查看文件具体改动以及对应的改动者，忽略空格。alias gbnm='git branch --no-merged' # 打印未被合并的分支alias gbr='git branch --remote' # 只列出远端分支alias gbs='git bisect' alias gbsb='git bisect bad'alias gbsg='git bisect good'alias gbsr='git bisect reset'alias gbss='git bisect start'alias gc='git commit -v'alias gca='git commit -v -a'alias gcam='git commit -a -m'alias gcsm='git commit -s -m'alias gcb='git checkout -b'alias gcf='git config --list'alias gcl='git clone --recursive'alias gclean='git clean -fd'alias gpristine='git reset --hard &amp;&amp; git clean -dfx'alias gcm='git checkout master'alias gcd='git checkout develop'alias gcmsg='git commit -m'alias gco='git checkout'alias gcount='git shortlog -sn'alias gcp='git cherry-pick'alias gcpa='git cherry-pick --abort'alias gcpc='git cherry-pick --continue'alias gcs='git commit -S'alias gd='git diff'alias gdca='git diff --cached'alias gdct='git describe --tags `git rev-list --tags --max-count=1`'alias gdt='git diff-tree --no-commit-id --name-only -r'alias gdw='git diff --word-diff'alias gf='git fetch'alias gfa='git fetch --all --prune'alias gfo='git fetch origin'永久添加环境变量1echo env=\"test\" &gt;&gt; /etc/environment]]></content>
      <categories>
        <category>效率</category>
        <category>awesome</category>
      </categories>
      <tags>
        <tag>awesome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS？？？]]></title>
    <url>%2FCSS%EF%BC%9F%EF%BC%9F%EF%BC%9F.html</url>
    <content type="text"><![CDATA[真正的勇士敢于直面纷繁的叠层样式表前言该博文主要用于记录各种在调整CSS以满足各种各样需求酷炫的效果中遇到的问题，以及解决方案。CSS选择器基础类选择器类选择器允许以一种独立于文档元素的方式来指定样式。该选择器可以单独使用，也可以与其他元素结合使用。要应用样式而不考虑具体设计的元素，最常用的方法就是使用类选择器。1&lt;p class="p-class"&gt;test&lt;/p&gt;123.p-class &#123; color: red;&#125;ID选择器ID 选择器允许以一种独立于文档元素的方式来指定样式。意味着当需要某一特定的标签具有特定的效果时，ID选择器是最好的效果1&lt;p id="mostimportant"&gt;test&lt;/p&gt;1234#mostimportant &#123; color: red; font-weight: bold; &#125;分组选择当需要多个选择器都具有相同的CSS属性时，则可以使用分组选择申明。123&lt;p class="p-class"&gt;test&lt;/p&gt;&lt;h1 class="h1-class"&gt;test&lt;/h1&gt;&lt;h2&gt;test&lt;/h2&gt;12345.p-class,.h1-class,h2 &#123; color: red;&#125;Footer置底最实用的Footer置底css设置–使用calc()实现动态计算。1234&lt;div class="content"&gt; &lt;!-- content --&gt;&lt;/div&gt;&lt;div class="footer"&gt;footer&lt;/div&gt;123456.content &#123; min-height: calc(100vh - （x + y)px); /*y为content与footer之间的距离*/&#125;.footer &#123; height: x px;&#125;Modal设置最大高度以及滚动1234.modal .modal-body &#123; max-height: 420px; overflow-y: auto;&#125;flex布局2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。使用flex布局，既可以轻松实现各种布局方案。任何容器都可以使用display: flex启用flex布局。水平布局而flex-direction属性决定主轴的方向（即项目的排列方向），它能取四个值：row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。那么实现水平布局即可轻松实现：1234&lt;div class="horizon"&gt; &lt;div&gt;row 1&lt;/div&gt; &lt;div&gt;row 2&lt;/div&gt;&lt;/div&gt;1234.horizion &#123; display: flex; flex-direction: row;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vue中使用scss]]></title>
    <url>%2FVue%2F%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8scss.html</url>
    <content type="text"><![CDATA[使用 &lt;style lang=&#39;scss&#39;&gt;解决方案1npm install -D sass-loader node-sass然后在webpack config中添加1234567891011121314151617181920module.exports = &#123; module: &#123; rules: [ // ... other rules omitted``` // this will apply to both plain `.scss` files // AND `&lt;style lang="scss"&gt;` blocks in `.vue` files &#123; test: /\.scss$/, use: [ 'vue-style-loader', 'css-loader', 'sass-loader' ] &#125;]``` &#125;, // plugin omitted&#125;现在就可以导入scss文件了。1import 'style.scss'或者123&lt;style lang="scss"&gt;/* write SCSS here */&lt;/style&gt;]]></content>
      <categories>
        <category>Vue.js</category>
        <category>scss</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJS项目初始化]]></title>
    <url>%2FVue%2FVueJS%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[安装Vue-CLI 3官方文档初始化项目12345sudo npm install -g @vue/clivue create my-projectcd my-projectnpm installnpm run devESlint修复配置 - WebStorm通过配置ESlint自动修复语法风格以满足ES标准添加External Tools在WebStorm/Preference/External Tools/中通过 + 按键添加ESlint fix添加快捷键在WebStorm/Preference/中搜索 Eslint-fix 添加快捷键使用在任意js文件使用之前设置的快捷键，即可完成ESlint fix]]></content>
      <categories>
        <category>Vue.js</category>
        <category>setup</category>
      </categories>
      <tags>
        <tag>setup</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04服务器基础构建]]></title>
    <url>%2FUbuntu%2FUbuntu16.04%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA.html</url>
    <content type="text"><![CDATA[良好的基础决定上层建筑oh-my-zsh安装前置依赖1sudo apt-get install zsh git安装 oh-my-zsh官方文档1sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"插件参见-效率安装Python3.6[参见]前端安装 Node.js官方下载 或者直接通过包管理工具安装12curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -sudo apt-get install -y nodejs安装并配置 npm12sudo apt-get install npmnpm config set registry=http://registry.npm.taobao.orgDocker安装 Docker CE过程较多，直接参照官方文档安装完之后，配置阿里云镜像加速——阿里云加速可选安装 docker-compose官方文档1pip3 install docker-compose安装 Nginx1sudo apt-get install nginx修复 Nginx 在 Ubuntu 下的 Bug1234sudo mkdir /etc/systemd/system/nginx.service.dsudo printf "[Service]\nExecStartPost=/bin/sleep 0.1\n" &gt; /etc/systemd/system/nginx.service.d/override.confsudo systemctl daemon-reloadsudo systemctl restart nginxSupervisorSupervisor是Unix平台下后台进程管理工具安装由于Supervisor开发团队高稳定性的要求，目前PyPi上supervisor的版本只支持Python2， 意味着安装Supervisor只能通过pip2 安装:1pip2 install supervisor如果需要支持Python3，则需要直接安装github上release的版本配置文件Supervisor默认自动搜索 supervisor.conf 文件，以支持 supervisord 和 supervisortl 的运行。默认搜索目录：$CWD/supervisord.conf$CWD/etc/supervisord.conf/etc/supervisord.conf/etc/supervisor/supervisord.conf (3.3.0 版本以上)../etc/supervisord.conf (相对于执行目录)../supervisord.conf (相对于执行目录)详细配置直接参考官方文档配置文件样例CertbotCertbot帮助网站自动免费生成HTTPS证书，并且自动续期。官方文档安装12345sudo apt-get updatesudo apt-get install software-properties-commonsudo add-apt-repository ppa:certbot/certbotsudo apt-get updatesudo apt-get install python-certbot-nginx]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>setup</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>Server</tag>
        <tag>setup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04构建Python3.6开发环境]]></title>
    <url>%2FPython%2FUbuntu16.04%E5%AE%89%E8%A3%85Python3.6.html</url>
    <content type="text"><![CDATA[Python is an easy to learn, powerful programming language.Python Tutorial安装Python3.6Ubuntu 14.04 and 16.04添加add-apt-repository命令1sudo apt-get install software-properties-common通过PPA安装123sudo add-apt-repository ppa:jonathonf/python-3.6sudo apt-get updatesudo apt-get install python3.6安装python-dev用于避免安装包时出缺少 Python.h 而安装失败1sudo apt-get install python3.6-dev安装pip12wget https://bootstrap.pypa.io/get-pip.pypython3.6 get-pip.py安装pipenv这个库相当于是环境管理和包管理二合一，由 Kenneth Reitz （Requests 的作者 ）编写，现在移交给 Python 官方来维护，提供比 pip 体验更好的开发包管理。它的 Slogon 是Python Development Workflow for Humans，用来解决各种环境不一致、安装包的问题，可参见官方文档1pip3.6 install pipenv构建pipenv环境生成Pipfile, 添加阿里源123cd your-projectpipenv lockvim Pipfile[[source]]url = “https://pypi.org/simple&quot;url = “https://mirrors.aliyun.com/pypi/simple/&quot;verify_ssl = truename = “pypi”[packages][dev-packages][requires]python_version = “3.6”123pipenv install ipythonpipenv shellipython]]></content>
      <categories>
        <category>Python</category>
        <category>setup</category>
      </categories>
      <tags>
        <tag>Ubuntu16.04</tag>
        <tag>setup</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解异步事件机制]]></title>
    <url>%2FPython%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[“知其然，知其所以然”前言通过了解异步设计的由来，来深入理解异步事件机制什么是异步同步并发(Concurrency)线程(Thread)I/O多路复用异步(Asynchronous)回调(Callback)参考文献什么是异步为了深入理解异步的概念，就必须先了解异步设计的由来。同步显然易见的是，同步的概念随着我们学习第一个输出Hello World的程序，就已经深入人心。然而我们也很容易忘记一个事实：一个现代编程语言(如Python)做了非常多的工作，来指导和约束你如何去构建你自己的一个程序。123456def f(): print("in f()")def g(): print("in g()")f()g()你知道in g()一定输出在in f()之后，即函数f完成前函数g不会执行。这即为同步。在现代编程语言的帮助下，这一切显得非常的自然，从而也让我们可以将我们的程序分解成松散耦合的函数：一个函数并不需要关心谁调用了它，它甚至可以没有返回值，只是完成一些操作。当然关于这些是怎么具体实现的就不探究了，然而随着一个程序的功能的增加，同步设计的开发理念并不足以实现一些复杂的功能。并发写一个程序每隔3秒打印“Hello World”，同时等待用户命令行的输入。用户每输入一个自然数n，就计算并打印斐波那契函数的值F(n)，之后继续等待下一个输入由于等待用户输入是一个阻塞的操作，如果按照同步的设计理念：如果用户未输入，则意味着接下来的函数并不会执行，自然没有办法做到一边输出“Hello World”，一边等待用户输入。为了让程序能解决这样一个问题，就必须引入并发机制，即让程序能够同时做很多事，线程是其中一种。线程具体代码在example/hello_threads.py中。12345678910111213141516171819202122from threading import Threadfrom time import sleepfrom time import timefrom fib import timed_fibdef print_hello(): while True: print("&#123;&#125; - Hello world!".format(int(time()))) sleep(3)def read_and_process_input(): while True: n = int(input()) print('fib(&#123;&#125;) = &#123;&#125;'.format(n, timed_fib(n)))def main(): # Second thread will print the hello message. Starting as a daemon means # the thread will not prevent the process from exiting. t = Thread(target=print_hello) t.daemon = True t.start() # Main thread will read and process input read_and_process_input()if __name__ == '__main__': main()对于之前那样的问题，引入线程机制就可以解决这种简单的并发问题。而对于线程我们应该有一个简单的认知：一个线程可以理解为指令的序列和CPU执行的上下文的集合。一个同步的程序即进程，有且只会在一个线程中运行，所以当线程被阻塞，也就意味着整个进程被阻塞一个进程可以有多个线程，同一个进程中的线程共享了进程的一些资源，比如说内存，地址空间，文件描述符等。线程是由操作系统的调度器来调度的， 调度器统一负责管理调度进程中的线程。系统的调度器决定什么时候会把当前线程挂起，并把CPU的控制器交个另一个线程。这个过程称之为称上下文切换，包括对于当前线程上下文的保存、对目标线程上下文的加载。上下文切换会对性能产生影响，因为它本身也需要CPU的周期来执行I/O多路复用而随着现实问题的复杂化，如10K问题。在Nginx没有流行起来的时候，常被提到一个词 10K（并发1W）。在互联网的早期，网速很慢、用户群很小需求也只是简单的页面浏览，所以最初的服务器设计者们使用基于进程/线程模型，也就是一个TCP连接就是分配一个进程(线程)。谁都没有想到现在Web 2.0时候用户群里和复杂的页面交互问题，而现在即时通信和实在实时互动已经很普遍了。那么你设想如果每一个用户都和服务器保持一个（甚至多个）TCP连接才能进行实时的数据交互，别说BAT这种量级的网站，就是豆瓣这种比较小的网站，同时的并发连接也要过亿了。进程是操作系统最昂贵的资源，一台机器无法创建很多进程。如果要创建10K个进程，那么操作系统是无法承受的。就算我们不讨论随着服务器规模大幅上升带来复杂度几何级数上升的问题，采用分布式系统，只是维持1亿用户在线需要10万台服务器，成本巨大，也只有FLAG、BAT这样公司才有财力购买如此多的服务器。而同样存在一些原因，让我们避免考虑多线程的方式：线程在计算和资源消耗的角度来说是比较昂贵的。线程并发所带来的问题，比如因为共享的内存空间而带来的死锁和竞态条件。这些又会导致更加复杂的代码，在编写代码的时候需要时不时地注意一些线程安全的问题。为了解决这一问题，出现了「用同一进程/线程来同时处理若干连接」的思路，也就是I/O多路复用。以Linux操作系统为例，Linux操作系统给出了三种监听文件描述符的机制，具体实现可参考：select: 每个连接对应一个描述符（socket），循环处理各个连接，先查下它的状态，ready了就进行处理，不ready就不进行处理。但是缺点很多：每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大select支持的文件描述符数量太小了，默认是1024poll: 本质上和select没有区别，但是由于它是基于链表来存储的，没有最大连接数的限制。缺点是：大量的的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。poll的特点是「水平触发(只要有数据可以读，不管怎样都会通知)」，如果报告后没有被处理，那么下次poll时会再次报告它。epoll: 它使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。epoll支持水平触发和边缘触发，最大的特点在于「边缘触发」，它只告诉进程哪些刚刚变为就绪态，并且只会通知一次。使用epoll的优点很多：没有最大并发连接的限制，能打开的fd的上限远大于1024（1G的内存上能监听约10万个端口）效率提升，不是轮询的方式，不会随着fd数目的增加效率下降内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销综上所述，通过epoll的机制，给现代高级语言提供了高并发、高性能解决方案的基础。而同样FreeBSD推出了kqueue，Windows推出了IOCP，Solaris推出了/dev/poll。而在Python3.4中新增了selectors模块，用于封装各个操作系统所提供的I/O多路复用的接口。那么之前同样的问题，我们可以通过I/O多路复用的机制实现并发。写一个程序每隔3秒打印“Hello World”，同时等待用户命令行的输入。用户每输入一个自然数n，就计算并打印斐波那契函数的值F(n)，之后继续等待下一个输入通过最基础的轮询机制(poll)，轮询标准输入(stdin)是否变为可读的状态，从而当标准输入能被读取时，去执行计算Fibonacci数列。然后判断时间是否过去三秒钟，从而是否输出”Hello World!”.具体代码在example/hello_selectors_poll.py中。注意：在Windows中并非一切都是文件，所以该实例代码无法在Windows平台下运行。123456789101112131415161718192021222324import selectorsimport sysfrom time import timefrom fib import timed_fibdef process_input(stream): text = stream.readline() n = int(text.strip()) print('fib(&#123;&#125;) = &#123;&#125;'.format(n, timed_fib(n)))def print_hello(): print("&#123;&#125; - Hello world!".format(int(time())))def main(): selector = selectors.DefaultSelector() # Register the selector to poll for "read" readiness on stdin selector.register(sys.stdin, selectors.EVENT_READ) last_hello = 0 # Setting to 0 means the timer will start right away while True: # Wait at most 100 milliseconds for input to be available for event, mask in selector.select(0.1): process_input(event.fileobj) if time() - last_hello &gt; 3: last_hello = time() print_hello()if __name__ == '__main__': main()从上面解决问题的设计方案演化过程，从同步到并发，从线程到I/O多路复用。可以看出根本思路去需要程序本身高效去阻塞，让CPU能够执行核心任务。意味着将数据包处理，内存管理，处理器调度等任务从内核态切换到应用态，操作系统只处理控制层，数据层完全交给应用程序在应用态中处理。极大程度的减少了程序在应用态和内核态之间切换的开销，让高性能、高并发成为了可能。异步通过之前的探究，不难发现一个同步的程序也能通过操作系统的接口实现“并发”，而这种“并发”的行为即可称之为异步。之前通过I/O复用的所提供的解决方案，进一步抽象，即可抽象出最基本的框架事件循环(Event Loop)，而其中最容易理解的实现，则是回调(Callback).回调通过对事件本身的抽象，以及其对应的处理函数(handler)，可以实现如下算法：维护一个按时间排序的事件列表，最近需要运行的定时器在最前面。这样的话每次只需要从头检查是否有超时的事件并执行它们。bisect.insort使得维护这个列表更加容易，它会帮你在合适的位置插入新的定时器事件组。具体代码在example/hello_event_loop_callback.py中。注意：在Windows中并非一切都是文件，所以该实例代码无法在Windows平台下运行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from bisect import insortfrom fib import timed_fibfrom time import timeimport selectorsimport sysclass EventLoop(object): """ Implements a callback based single-threaded event loop as a simple demonstration. """ def __init__(self, *tasks): self._running = False self._stdin_handlers = [] self._timers = [] self._selector = selectors.DefaultSelector() self._selector.register(sys.stdin, selectors.EVENT_READ) def run_forever(self): self._running = True while self._running: # First check for available IO input for key, mask in self._selector.select(0): line = key.fileobj.readline().strip() for callback in self._stdin_handlers: callback(line) # Handle timer events while self._timers and self._timers[0][0] &lt; time(): handler = self._timers[0][1] del self._timers[0] handler() def add_stdin_handler(self, callback): self._stdin_handlers.append(callback) def add_timer(self, wait_time, callback): insort(self._timers, (time() + wait_time, callback)) def stop(self): self._running = Falsedef main(): loop = EventLoop() def on_stdin_input(line): if line == 'exit': loop.stop() return n = int(line) print("fib(&#123;&#125;) = &#123;&#125;".format(n, timed_fib(n))) def print_hello(): print("&#123;&#125; - Hello world!".format(int(time()))) loop.add_timer(3, print_hello) def f(x): def g(): print(x) return g loop.add_stdin_handler(on_stdin_input) loop.add_timer(0, print_hello) loop.run_forever()if __name__ == '__main__': main()参考文献Some thoughts on asynchronous API design in a post-async/await worldPython 开源异步并发框架的未来Understanding Asyncio Node.js Python3.4使用Python进行并发编程-asyncio篇(一)select、poll、epoll之间的区别总结[整理]]]></content>
      <categories>
        <category>Python</category>
        <category>Asynchronous</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Asynchronous</tag>
      </tags>
  </entry>
</search>
